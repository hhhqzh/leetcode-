/**
    问题描述
    有 N 个信件和信箱，每封信件对应一个正确信箱位置。
    现在它们被打乱，求错误装信方式的数量。保证每一封信都装在错误的位置。
**/

/**
 * 定义一个dp[n]数组，存放错误方式数量
 * 比如dp[i]，存放有i封信放在i个信箱的错误方式
 * 
 * 转移方程建立：
 * 对于第n封信，假设放在第k个信箱，对于第k封信，有两种情况
 * （1）第k封信存放在第n封信的信箱里
 *       剩下的n-2个信箱和信件，有dp[n-2]种错误的存放方法，k的取值范围为(1-n-1)
 *       共有(n-1)*dp[n-2]中错误装信方法
 * （2）第k封信不存放在第n封信的信箱里
 *      此时有n-1封信，每封信对应着1个信箱，此时第k封信应该对应着第n封信的信箱（我们可以把信箱 N 当做信件 K 的“专属信箱”）。）
 *      因为k不能存放在n的信箱里。
 *      所以，还有n-1封信和n-1个信箱，即dp[n-1]
 *      又∵k有n-1个取值，所以共有(n-1)*dp[n-1]中错误装信的方法
 * 
 * */


int MailMisalignment(int n){
    if(n == 0 || n == 1)
        return 0;
    int* dp = new int(n + 1);
    dp[0] = dp[1] = 0;
    dp[2] = 1;
    for(int i = 3; i < n; ++i)
        dp[i] = (i - 1) * (dp[i-1] + dp[i-2]);
    return dp[n];
}